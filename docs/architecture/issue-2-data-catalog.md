# Architecture: Data Catalog — Agent Discovery and Use of Org Data Sources (Issue #2)

## Technical Design

### Approach

Introduce a cluster-scoped `DataSource` CRD (`iaf.io/v1alpha1`) that platform operators register once; agents consume it via three new MCP tools and one MCP resource. `attach_data_source` copies the DataSource's credential Secret from the operator-managed namespace into the session namespace (agent never sees the raw secret), records the attachment in the Application CR, and the controller injects the env vars into the Deployment on the next reconcile. Detachment is handled automatically when the app is deleted (Secret ownership). Agents cannot enumerate Secret contents — only metadata and schema are exposed.

**⚠ High risk — this design touches cross-namespace Secret copying, new CRD creation, and audit requirements. Escalating `needs-security-review`.**

### Changes Required

**New `api/v1alpha1/datasource_types.go`**:
```go
// +kubebuilder:object:root=true
// +kubebuilder:resource:scope=Cluster
// +kubebuilder:printcolumn:name="Kind",type=string,JSONPath=`.spec.kind`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

type DataSource struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`
    Spec   DataSourceSpec   `json:"spec,omitempty"`
    Status DataSourceStatus `json:"status,omitempty"`
}

type DataSourceSpec struct {
    // Kind is the type of data source (postgres, mysql, s3, http-api, kafka).
    Kind        string `json:"kind"`
    Description string `json:"description,omitempty"`
    // Schema is an optional free-text or JSON Schema string describing the data.
    Schema      string `json:"schema,omitempty"`
    // Tags are arbitrary labels for filtering.
    Tags        []string `json:"tags,omitempty"`
    // SecretRef references the operator-created Secret containing connection credentials.
    SecretRef   DataSourceSecretRef `json:"secretRef"`
    // EnvVarMapping maps Secret data keys to environment variable names injected into apps.
    // Example: {"host": "POSTGRES_HOST", "password": "POSTGRES_PASSWORD"}
    EnvVarMapping map[string]string `json:"envVarMapping"`
}

type DataSourceSecretRef struct {
    // Name of the Secret.
    Name      string `json:"name"`
    // Namespace where the Secret lives (operator-managed, e.g., "iaf-system").
    Namespace string `json:"namespace"`
}

type DataSourceStatus struct {
    // AttachedApps is the count of applications currently using this data source.
    // +optional
    AttachedApps int32 `json:"attachedApps,omitempty"`
}

// +kubebuilder:object:root=true
type DataSourceList struct { ... }
```

**Updated `api/v1alpha1/application_types.go`**:
- Add `AttachedDataSources []AttachedDataSource` field to `ApplicationSpec`:
  ```go
  type AttachedDataSource struct {
      // DataSourceName is the name of the DataSource CR.
      DataSourceName string `json:"dataSourceName"`
      // SecretName is the name of the copied Secret in this app's namespace.
      SecretName     string `json:"secretName"`
  }
  ```
- Add to `ApplicationSpec`:
  ```go
  // AttachedDataSources lists data sources whose credentials are injected into this app.
  // +optional
  AttachedDataSources []AttachedDataSource `json:"attachedDataSources,omitempty"`
  ```

**`api/v1alpha1/groupversion_info.go`** — register `DataSource`, `DataSourceList` in `SchemeBuilder.Register(...)`.

**`api/v1alpha1/zz_generated.deepcopy.go`** — regenerated by `make generate`.

**New `internal/mcp/tools/data_sources.go`** — three registration functions:

1. `RegisterListDataSources(server, deps)`:
   - Input: `session_id` (validated), optional `kind` filter, optional `tags` filter (comma-separated)
   - Lists all `DataSource` CRs cluster-wide via `deps.Client.List`
   - Returns array of metadata: `{ "name", "kind", "description", "tags", "schema" }` — **no credential data**
   - Applies `kind`/`tags` filters in-process (no label selector — DataSources are cluster-scoped; filtering all is acceptable at expected scale of O(100) data sources)

2. `RegisterGetDataSource(server, deps)`:
   - Input: `session_id`, `name`
   - Gets a single DataSource CR
   - Returns: `{ "name", "kind", "description", "schema", "tags", "envVarNames" }` where `envVarNames` is the list of env var names the agent can expect (the values of `EnvVarMapping`) — **no Secret keys, no credential values**

3. `RegisterAttachDataSource(server, deps)`:
   - Input: `session_id`, `datasource_name`, `app_name`
   - Resolves session → namespace
   - Gets DataSource CR; returns error if not found
   - Gets Application CR `{app_name}` in session namespace; returns error if not found
   - Checks if DataSource already attached (idempotent)
   - Gets the DataSource's Secret from `spec.secretRef.namespace`/`spec.secretRef.name`
   - Creates a copy in the session namespace:
     - Name: `iaf-ds-{datasource_name}` (max 63 chars; truncate if needed)
     - Labels: `iaf.io/datasource: {datasource_name}`, `iaf.io/managed-by: iaf`
     - OwnerReferences: set owner to the Application CR (`ctrl.SetControllerReference`) so it's garbage-collected when the app is deleted
     - Data: exact copy of source Secret's `Data` map
     - Type: same type as source Secret
   - Patches the Application CR: appends to `spec.attachedDataSources`
   - **Audit log**: `logger.Info("data source attached", "session", sessionID, "datasource", dsName, "app", appName, "namespace", namespace)`
   - Returns: `{ "datasource": "...", "app": "...", "envVarNames": [...], "message": "Data source attached; app will restart to pick up env vars" }`

**Updated `internal/controller/application_controller.go`**:
- In `reconcileDeployment`: after building the `envVars` slice from `app.Spec.Env`, also add env vars from `app.Spec.AttachedDataSources`:
  ```go
  for _, ads := range app.Spec.AttachedDataSources {
      // For each entry in the DataSource's EnvVarMapping, add a valueFrom.secretKeyRef
      // We need the DataSource CR to get the mapping — fetch it
      var ds iafv1alpha1.DataSource
      if err := r.Get(ctx, client.ObjectKey{Name: ads.DataSourceName}, &ds); err != nil {
          // DataSource may have been deleted — skip gracefully, log warning
          logger.Info("attached DataSource not found, skipping env injection", "datasource", ads.DataSourceName)
          continue
      }
      for secretKey, envVarName := range ds.Spec.EnvVarMapping {
          envVars = append(envVars, corev1.EnvVar{
              Name: envVarName,
              ValueFrom: &corev1.EnvVarSource{
                  SecretKeyRef: &corev1.SecretKeySelector{
                      LocalObjectReference: corev1.LocalObjectReference{Name: ads.SecretName},
                      Key: secretKey,
                  },
              },
          })
      }
  }
  ```
- Add RBAC markers:
  ```go
  // +kubebuilder:rbac:groups=iaf.io,resources=datasources,verbs=get;list;watch
  // +kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;create;delete
  ```

**New `internal/mcp/resources/data_catalog.go`**:
- `RegisterDataCatalog(server, deps)` registers `iaf://catalog/data-sources` as a static MCP resource
- Handler: lists all DataSource CRs, builds JSON index: `[{ "name", "kind", "description", "tags" }]`
- MIME type: `application/json`
- **No credential data included**

**`internal/mcp/server.go`**: call `RegisterListDataSources`, `RegisterGetDataSource`, `RegisterAttachDataSource`, `RegisterDataCatalog`; update `serverInstructions`.

**Tests** (`internal/mcp/tools/data_sources_test.go`):
- Fake K8s client pre-populated with sample DataSource CRs and a sample Secret in `iaf-system`
- `TestListDataSources_FiltersWork`
- `TestGetDataSource_NoCredentialData`: verify output never includes Secret key values
- `TestAttachDataSource_SecretCopied`: verify copy created in session namespace with correct labels and owner ref
- `TestAttachDataSource_Idempotent`: calling twice does not duplicate entry in `attachedDataSources`
- `TestAttachDataSource_AppNotFound`
- `TestAttachDataSource_DataSourceNotFound`
- `TestAttachDataSource_SecretCopy_NeverExposeData`: verify tool output never includes Secret `data` values

### Data / API Changes

**New cluster-scoped CRD**: `iaf.io/v1alpha1/DataSource`

**Updated CRD**: `Application.spec.attachedDataSources` — new optional array field.

**New K8s resources** (created by `attach_data_source` tool):
- `Secret` in session namespace, name `iaf-ds-{datasource_name}`, owned by the Application.

**MCP resource**: `iaf://catalog/data-sources` (static, `application/json`).

**New MCP tools**: `list_data_sources`, `get_data_source`, `attach_data_source`.

**`get_data_source` output** (safe subset — no credentials):
```json
{
  "name": "prod-postgres",
  "kind": "postgres",
  "description": "Production PostgreSQL database",
  "schema": "Tables: users, orders, products",
  "tags": ["production", "sql"],
  "envVarNames": ["POSTGRES_HOST", "POSTGRES_PORT", "POSTGRES_USER", "POSTGRES_PASSWORD", "DATABASE_NAME"]
}
```

**`attach_data_source` output**:
```json
{
  "datasource": "prod-postgres",
  "app": "myapp",
  "envVarNames": ["POSTGRES_HOST", "POSTGRES_PORT", "POSTGRES_USER", "POSTGRES_PASSWORD", "DATABASE_NAME"],
  "message": "Data source 'prod-postgres' attached to app 'myapp'. The app will restart to pick up the new environment variables."
}
```

**Operator registers a DataSource** (via `kubectl apply` — not via agent MCP tools):
```yaml
apiVersion: iaf.io/v1alpha1
kind: DataSource
metadata:
  name: prod-postgres
spec:
  kind: postgres
  description: "Production PostgreSQL database (read-only replica)"
  tags: [production, sql, read-only]
  schema: "Tables: users (id, email, created_at), orders (id, user_id, total, status)"
  secretRef:
    name: prod-postgres-creds
    namespace: iaf-system
  envVarMapping:
    host:     POSTGRES_HOST
    port:     POSTGRES_PORT
    database: POSTGRES_DB
    username: POSTGRES_USER
    password: POSTGRES_PASSWORD
```

### Multi-tenancy & Shared Resource Impact

- **DataSource metadata is global**: all sessions see all registered DataSources. This is by design — data discovery is platform-wide. If per-team scoping is needed, that is a future `DataSourcePolicy` feature.
- **Secret copy isolation**: each session gets its own copy of the credential Secret. Session A's copy cannot be read by session B. The copy is owned by the Application, so it is garbage-collected when the app is deleted — no orphaned secrets.
- **Cross-namespace Secret read**: `attach_data_source` reads a Secret from `iaf-system` (the `DataSourceSecretRef.Namespace`). The MCP server's service account must have `get` on Secrets in `iaf-system`. This is a controlled cross-namespace access (read only, from a platform-controlled namespace). No agent-supplied namespace is used — only the `secretRef.namespace` from the DataSource CR (which operators create, not agents).
- **EnvVar collision**: if two DataSources define the same env var name, the second `attach_data_source` call will produce a Deployment with a duplicate env var — last-write-wins or Kubernetes rejects it. Design requires: `attach_data_source` must check for env var name collisions before patching the Application. If a collision is detected, return a machine-actionable error: `"env var POSTGRES_PASSWORD is already defined by data source 'other-postgres'; choose one or use a different app"`
- **AttachedDataSources and hot-restart**: attaching triggers an Application CR update, which triggers a controller reconcile, which updates the Deployment spec with new env vars. Kubernetes performs a rolling restart. Document this expected restart in the tool output.

### Security Considerations

- **Credentials never in tool output**: `get_data_source` returns only `envVarNames` (the env var names, not values). `attach_data_source` output lists env var names only. The copied Secret in the session namespace is never read back and surfaced by any tool. Tests must explicitly verify this invariant.
- **Agent cannot register DataSources**: `DataSource` CRs are cluster-scoped and require `create` permission on `iaf.io/datasources` — the platform SA has only `get;list;watch` for the controller and MCP tools. Operators use `kubectl` to register data sources. This is a deliberate design decision to keep credential registration out of the agent-accessible surface.
- **Agent cannot choose the SecretRef**: `DataSourceSpec.SecretRef` is set by the operator at registration time. The agent only supplies the DataSource name in `attach_data_source`. The actual Secret namespace and name come from the DataSource CR, not from agent input. This prevents path traversal / reference injection attacks.
- **RBAC for cross-namespace Secret read**: the platform SA needs `get` on Secrets in `iaf-system` (or whatever namespace the DataSource's SecretRef points to). Use a targeted Role + RoleBinding in `iaf-system`, not a cluster-wide `get` on all Secrets. Add RBAC marker: `// +kubebuilder:rbac:groups="",resources=secrets,verbs=get,namespace=iaf-system` — note: controller-gen does not support namespace-scoped markers; this requires a manually crafted Role + RoleBinding in `config/rbac/`. Document this in the deployment guide.
- **Audit trail**: every `attach_data_source` call must be logged with `session_id`, `datasource_name`, `app_name`, and namespace. This satisfies the audit requirement without storing PII or credentials.
- **Secret data type consistency**: when copying the Secret, preserve the source Secret's `Type` field. Do not copy `kubernetes.io/service-account-token` or `kubernetes.io/dockerconfigjson` types — validate that the source type is one of: `Opaque`, `kubernetes.io/basic-auth`, or a custom application type. Reject others.
- **EnvVar name injection**: `EnvVarMapping` values (env var names) are set by operators in the DataSource CR. However, validate env var names in the controller using `validation.ValidateEnvVarName` (from issue #14 design) before injecting into the Deployment — defence-in-depth in case a malicious operator tried to inject POSIX-invalid env var names.

**⚠ Needs security review**:
- Cross-namespace Secret read: operator-restricted vs cluster-wide ClusterRole
- Whether all registered DataSources should be visible to all agents (flat access model) vs RBAC-gated per DataSource
- Secret data type validation completeness
- Audit log completeness and storage (structured logs vs dedicated audit trail)
- EnvVar collision risk in multi-attach scenarios
- What happens if the source Secret is deleted after `attach_data_source` — the copied Secret in the session namespace persists (it is a copy, not a reference); the app continues working until restarted. Document this explicitly.

### Resource & Performance Impact

- Per data source attachment: 1 Secret created in session namespace (~1 KB), 1 Application CR patch, 1 controller reconcile + Deployment rolling restart (~5–30 seconds depending on cluster).
- `list_data_sources` and `iaf://catalog/data-sources`: 1 K8s API call to list cluster-scoped DataSource CRs. At O(100) DataSources: negligible latency.
- Controller: `reconcileDeployment` now fetches each DataSource CR for each attached source. At O(5) attached sources per app: 5 extra Get calls per reconcile. Acceptable; DataSource CRs should be cached by controller-runtime's informer cache.
- `make generate` adds the new CRD YAML to `config/crd/`.

### Migration / Compatibility

- New cluster-scoped CRD — purely additive. `make generate` + `make install-crds` required.
- Application CR gains new optional field `attachedDataSources` — backward-compatible (omitempty).
- Controller update is additive (new logic in `reconcileDeployment` for AttachedDataSources; no change to existing paths).
- Existing apps without `attachedDataSources` are unaffected.

### Open Questions for Developer

1. **DataSource CR create/update access for operators**: should the operator be able to create DataSources via the REST API (`POST /api/v1/admin/datasources`) or only via `kubectl`? For now, `kubectl` only (agents cannot register data sources). Leave the admin REST API as a future issue.
2. **Hot-inject without restart**: the issue raises whether `attach_data_source` can hot-inject env vars without a pod restart. Answer: no. K8s `envFrom`/`env.valueFrom.secretKeyRef` requires a pod restart to take effect. The rolling restart is the expected mechanism. Document this clearly in tool output.
3. **Multiple DataSources with same env var**: design decision — return an error if `attach_data_source` would create a collision. The agent must resolve the conflict by naming env vars differently (this requires the operator to update the `EnvVarMapping`). Document this in `get_data_source` output so agents can check before attaching.
4. **Detach tool**: the issue does not specify a `detach_data_source` tool. Add it as an open item — agents should be able to remove a data source attachment (which patches the Application CR to remove the entry and deletes the copied Secret). Leave for a follow-up issue.
5. **Source Secret deletion**: if the operator deletes the source Secret in `iaf-system`, the copied Secret in the session namespace remains intact. The app continues working. If the operator wants to revoke access, they must also delete the copies or the Application CRs. Document this operational procedure.
6. **ClusterRole for DataSource list**: the MCP server and controller both need `list` on cluster-scoped DataSource CRs. Since DataSources are cluster-scoped, a ClusterRole is required. Confirm this is generated correctly by `make generate` after adding the RBAC markers.
